# Theoretical Backgrounds and Applications - 이론적 배경과 응용

## 깊이 우선 탐색과 간선의 분류

DFS을 수행하면서 모든 **간선**을 한 번 이상 만나게 된다. 만나는 간선들은 크게 두 가지로 나누어진다. "**아직 방문하지 않은 정점**으로 연결되는 간선"과 
"**이미 방문한 정점**으로 연결되는 간선"으로 나누어진다. 이미 방문한 정점으로 연결되는 간선은 쓸모 없어 보일 수 있다. 하지만 이 쓸모 없어 보이는 간선에 대한 정보를 잘 이용하면 그래프의 구조를 파악하는데 도움이 된다.

어떤 그래프를 DFS하면서 만나는 간선을 모으면 트리가 하나 만들어진다. 이러한 트리를 DFS 스패닝 트리(DFS Spanning Tree)라고 한다. DFS 스패닝 트리가 생성된 그래프의 간선들은 다음 네 가지 중 하나로 분류된다.

- **트리 간선(Tree Edge)**: DFS 스패닝 트리에 포함된 간선.

- **순방향 간선(Forward Edge)**: DFS 스패닝 트리의 선조에서 자손으로(선조 -> 자손) 연결되지만 트리의 간선이 아닌 간선. (간선의 방향이 선조에서 자손으로의 방향은 맞지만 DFS 스패닝 트리에 속하지 않는 간선)

- **역방향 간선(Back Edge)**: DFS 스패닝 트리의 자손에서 선조로(자손 -> 선조) 연결되는 간선.

- **교차 간선(Cross Edge)**: 트리에서 선조와 자손 관계가 아닌 정점들 간의 연결된 간선. 위 세 가지 분류 외 나머지 모든 간선.

어떤 정점에서 DFS를 시작하느냐에 따라서 완전히 다른 스패닝 트리가 만들어질 수 있다. 이에 따라 간선들의 구분도 달라질 수 있다. 한 그래프에 속한 간선의 분류는 절대적인 것이 아니다.

## 무향 그래프 간선의 분류

### 무향 그래프에서는 교차 간선이 없다. 
    
어떤 간선 `(u, v)`가 교차 간선이기 위해서는 `v`가 먼저 방문된 후 `u`를 방문하지 않고 종료해야 한다. 무향 그래프의 경우 간선 `(u, v)`가 존재하면 이 간선을 이용해 `v`에서 `u`로 이동할 수 있기 때문에 교차 간선이 생길 수 없다. ( => 한 서브 트리를 DFS 하면서 가지 못했던 정점이 "나"를 향하고 있어야 한다. 무향 그래프에서는 일단 연결돼있으면 무조건 방문 가능하기 때문에 그런 상황은 불가능하다.)

### 무향 그래프에서는 순방향 간선과 역방향 간선의 구분이 없다.

무향 그래프에 포함된 간선은 방향이 없기 때문에 명확한 계층 구조가 만들어지지 않는다. DFS 스패닝 트리의 선조와 자손을 구분할 수 없다.

### 예제: 위상 정렬의 정당성 증명

간선의 분류는 그 자체가 유용하기보다는 그래프 알고리즘을 이해하고 증명하기 위한 도구로 유용하게 쓰인다. 가장 대표적인 간선 분류의 사용 예는 위상 정렬의 정당성 증명이다. 위상 정렬 알고리즘이 `dfs()`의 종료 역순으로 정점을 배열한다고 하자. `dfs(u)`가 `dfs(v)`보다 일찍 종료할 경우 `u`에서 `v`로 가는 간선이 존재할 수 없다는 것만 증명하면 정당성을 보일 수 있다.

- **`(u, v)`가 트리 간선이라면**: `dfs(u)`에서 `dfs(v)`를 호출한 것이다. `dfs(u)`가 `dfs(v)`보다 먼저 종료할 수 없다.

- **`(u, v)`가 순방향 간선이라면**: `u`가 `v`의 선조라는 뜻이다. `dfs(u)`가 `dfs(v)`보다 먼저 종료할 수 없다.

- **`(u, v)`가 역방향 간선이라면**: `v`가 `u`의 선조이므로 `v`에서 `u`로 가는 경로가 있다는 뜻이다. `v`에서 `u`로 가는 경로가 있는데 `(u, v)`가 존재한다고 하면 그래프에서 사이클이 존재하게 된다. 그러면 그래프가 DAG라는 가정이 모순된다. (위상 정렬을 할 수 있으려면 사이클이 있어선 안된다.)

- **`(u, v)`가 교차 간선이라면**: `dfs(v)`가 종료되고 나서 `u`를 방문했다는 뜻이다. `dfs(u)`가 먼저 종료했다는 것과 모순이다.

### 예제: 사이클 존재 여부 확인하기

방향 그래프에서 사이클의 존재를 판정하는데 간선 구분이 사용된다. 사이클의 존재 여부는 역방향 간선의 존재 여부와 동치이다.

사이클에 포함된 정점 중 DFS 과정에서 처음 만나는 정점을 `u`라고 합시다. `dfs(u)`는 `u`에서 갈 수 있는 정점들을 방문한 후에 탐색을 종료할 것이다. 따라서 dfs는 사이클에서 `u` 이전에 있는 정점을 `dfs(u)`가 종료하기 전에 방문하게 되는데, 그러면 이 정점에서 `u`로 가는 정점은 항상 역방향 간선이 된다.

> 사이클을 이루는 그래프의 한 정점 `u`에서 dfs를 실행한다고 하자. `u` 이전의 위치에서 `u`를 가리키는 정점을 `v`라고 하자. `dfs(u)`가 종료하기 전에 정점 `v`를 방문하게 된다. 그러면 `v`에서 `u`로 가는 간선은 항상 역방향 간선이 된다. (위 문단에 대한 나만의 정리)

## 간선을 구분하는 방법

간선 구분의 유용성을 알아보았다. 이제 그래프의 간선을 구분해보자.

가장 구분하기 쉬운 간선은 트리 간선이다. `dfs(u)` 중에 간선 `(u, v)`를 검사했을 때 `v`가 방문된 적이 없다면 이 간선을 따라가므로 `(u, v)`는 트리 간선이 된다. 반대로 이미 `v`를 방문했다고 하자. `v`를 이미 방문했다는 정보만으로는 `v`가 `u`의 자손인지, 부모인지, 둘 다 아닌지 알 수 없다. 이미 방문한 정점과의 관계를 알아내기 위해 탐색의 과정에서 "방문 여부" 외의 다른 정보를 저장해야한다.

한 가지 방법은 각 정점을 방문할 때 이 정점이 발견되었다는 정보와 함께 "몇 번째로 발견되었는지"를 같이 기록하는 것이다. 각 정점이 볓 번째로 발견되었는지를 배열 `discovered[]`에 저장한다고 하자. 이 정보를 통해서 순방향과 역방향, 교차 간선을 구분해낼 수 있다.

- `(u, v)`가 순방향 간선이라면: `v`는 `u`의 자손이어야 한다. 따라서 `v`는 `u`보다 더 늦게 발견되어야 한다. (`dfs(u)`의 상황에서 `discovered[v] == null`)

- `(u, v)`가 역방향 간선이라면: `v`는 `u`의 선조이어야 한다. 따라서 `v`는 `u`보다 더 먼저 발견되어야 한다. (`discovered[u]` > `discovered[v]`)

- `(u, v)`가 교차 간선이라면: `dfs(v)`가 종료된 후 `dfs(u)`가 호출되어야 한다. 따라서 `v`는 `u`보다 더 먼저 발견되어야 한다.

### 간선 구분하는 순서

1. 발견 순서 정보를 이용해 해당 간선이 순방향 간선인지 확인한다. `dfs(u)`의 상황에서 `discovered[v] == null`이라면 순방향 간선이다.

2. `dfs(u)`의 상황에서 `discovered[v] != null`이라면 이 간선이 역방향 간선인지 교차 간선인지 알 수 없다. 이 때 `dfs(v)`가 종료했는지 확인한다.

3. `dfs(v)`가 종료되지 않았다면 `v`는 `u`의 선조이므로 간선 `(u, v)`는 역방향 간선이 된다.

4. `dfs(v)`가 종료됐다면 `u`와 `v`는 선조와 자손의 관계가 아니므로 간선 `(u, v)`는 교차 간선이 된다. 

**간선을 구분하는 dfs의 구현**

```cpp
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// discovered[i] = i번 정점의 발견 순서
// finished[i] = dfs(i)가 종료했으면 1, 아니면 0
vector<int> discovered, finished;
// 지금까지 발견한 정점의 수
int counter;

void dfs2(int here) {
    discovered[here] = counter++;
    // 모든 인접 정점을 순회하면서
    for (int i = 0; i < adj[here].size(); i++) {
        int there = adj[here][i];
        cout << "(" << here << "," << there << ") is a ";
        // 아직 방문한 적이 없다면 방문한다.
        if (discovered[there] == -1) {
            cout << "tree edge" << "\n";
            dfs2(there);
        }
        // 만약 there가 here보다 늦게 발견됐으면 there는 here의 후손이다.
        else if (discovered[here] < discovered[there])
            cout << "forward edge" << "\n";
        // 만약 dfs2(there)가 아직 종료하지 않았으면 there는 here의 선조다.
        else if (finished[there] == 0)
            cout << "back edge" << "\n";
        // 이 외의 경우는 모두 교차 간선
        else 
            cout << "cross edge" << "\n";
    }
    finished[here] = 1;
}
```

### 예제: 절단점 찾기 알고리즘

dfs를 응용해 풀 수 있는 문제들을 조금 더 본격적으로 알아보겠다. 그 중 하나는 **그래프의 절단점(cut vertex)를 찾는 문제**이다. 무향 그래프에서 한 정점에 인접한 간선들을 모두 지웠을 때 그래프가 두 개 이상의 컴포넌트로 나누어지는 정점을 **무향 그래프의 절단점**이라고 한다.

어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가 이전보다 늘어났는지를 확인하는 것이다. 컴포넌트의 개수를 세는 것은 dfs로 간단하게 할 수 있다. 이 방법으로 모든 정점의 절단점 여부를 확인하면 dfs를 `|V|`(정점의 숫자)번 수행해야 한다. 놀랍게도 한 번의 dfs만으로 그래프의 모든 절단점을 찾을 수 있다. 탐색 과정에서 얻는 정보를 잘 이용해야 한다.

임의의 정점에서부터 깊이 우선 탐색을 수행해 DFS 스패닝 트리를 만들자. 이때 어떤 정점 `u`가 절단점인지 알아보자. 무향 그래프의 스패닝 트리에는 교차 간선이 없으므로, `u`와 연결된 정점들은 모두 `u`의 선조 아니면 자손이다. 이때 `u`의 자손들을 루트로 하는 서브트리들은 서로 분리되어 있다. 서브트리들 간에 간선이 있다면 교차 간선일 것이다. 하지만 무향 그래프에서는 교차 간선이 존재할 수 없다. 따라서 `u`가 지워졌을 때 그래프가 쪼개지지 않는 유일한 경우는 `u`의 선조와 자손들이 전부 역방향 간선으로 연결되어 있을 때 뿐이다.각 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 갈 수 있는 정점의 최소 깊이를 함수 `dfs2()`가 반환하게 하면 간단히 확인할 수 있다. 만약 `u`의 자손들이 모두 역방향 간선을 통해 `u`의 선조로 올라갈 수 있다면 `u`는 절단점이 아니다.

`u`가 스패닝 트리의 루트라서 선조가 없을 때에는 둘 이상의 자손을 가질 때에만 절단점이 된다. 루트인 `u`의 자손이 하나라면 `u`가 없더라도 컴포넌트의 수는 그대로다.

실제로 이 알고리즘을 구현할 때는 각 정점의 깊이를 비교하는 대신, 각 정점의 발견 순서를 비교하는 형태로 코드를 작성해 구현을 간단하게 할 수 있다. 우리가 결국 알고 싶은 것은 해당 서브트리가 `u`의 조상 중 하나와 연결되어 있는지이다. `u`의 조상들은 항상 `u`보다 먼저 발견되었을 것이다. 따라서 dfs 함수가 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견 순서를 반환하도록 하기만 하면 된다.

**무향 그래프에서 절단점을 찾는 알고리즘**

```cpp
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// 각 정점의 발견 순서. -1로 초기화 한다.
vector<int> discovered;
// 각 정점이 절단점인지 여부를 저장한다. false로 초기화한다.
vector<bool> inCutVertex;
int counter = 0;
// here를 루트로 하는 서브트리에 있는 절단점을 찾는다.
// 반환 값은 해당 서브트리에 역방향 간선으로 갈 수 있는 정점 중
// 가장 일찍 발견된 정점의 발견 시점. 처음 호출할 대는 isRoot=true로 둔다.
int findCutVertex(int here, bool isRoot) {
    // 발견 순서를 기록한다.
    discovered[here] = counter++;
    int ret = discovered[here];
    // 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 센다.
    int children = 0;
    for (int i = 0; i < adj[here].size(); i++) {
        int there = adj[here][i];
        if (discovered[there] == -1) {
            children++;
            // 이 서브트리에서 갈 수 있는 가장 높은 정점의 번호
            int subtree = findCutVertex(there, false);
            // 그 노드가 자기 자신 이하에 있다면 현재 위치는 절단점!
            if (!isRoot && subtree >= discovered[here])
                isCutVertex[here] = true;
            ret = min(ret, subtree);
        }
        else
            ret = min(ret, discovered[there]);
    }
    // 루트인 경우 절단점 판정은 서브트리의 개수로 한다.
    if (isRoot) isCutVertex[here] = (children >= 2);
    return ret;
}
```

**이중 결합 컴포넌트**

무향 그래프에서 절단점을 포함하지 않는 서브그래프를 이중 결합 컴포넌트(biconnected component)라고 부른다. 이중 결합 컴포넌트 내에서는 임의의 한 정점을 그래프에서 지우더라도 정점 간의 연결 관계가 유지된다.

### 예제: 다리 찾기

### 예제: 강결합 컴포넌트 분리

### 강결합 컴포넌트 분리를 위한 타잔의 알고리즘
